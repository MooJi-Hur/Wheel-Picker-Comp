
# 1초, 그리고 0.1px - Date Wheel Picker 만들기

## 시작하며

회원 가입 절차를 간소화 하기 위해 SMS 인증을 추가하기로 했어요.

UI팀은 이 좋은 기회를 놓치지 않고 회원가입 전면 리뉴얼을 시작했습니다.



PASS 인증은 많은 정보를 입력하는 대신,

사용자가 만 14세 미만인지 확인하기도 쉽습니다.

그러나 SMS 인증은 간편한 대신 사용자가 만 14세를 넘었는지 직접 물어봐야 하죠.

생년월일은 Date-Wheel-Picker 로 입력하기로 했습니다.



## 기능

<img src="https://user-images.githubusercontent.com/90231980/184641173-e0c2875e-1ed4-49b0-8652-df7b34d7e2b2.gif" height="300"/>


구현 결과물입니다.  


요구 사항은 간단합니다.

- 생년월일 탭 시 오늘 날짜 활성화

- 년도 범위: 1905년 ~ 사용자 접속 시점 년도

  

## 문제

UI 라이브러리를 사용하면 장점이 있습니다.

특히 다운로드 수가 많은 라이브러리는 여러 기기 환경에서도 안정성 있게 작동하여

개발 기간을 줄이는데에 크게 도움이 됩니다.  



물론, GUI 팀이 원하는 화면을 만들기 위해서는

CSS를 커스텀해야하고, 이 과정이 어려울 때가 있습니다.

보통 className을 이용하여 CSS를 커스텀하는 과정을 거치죠.  



Wheel-Picker Typescript.js 라이브러리는 모두 중요한 문제가 있었습니다.

**렌더링이 느렸어요.**



## 원인

년도는 1905년부터 필요했기 때문에,

대략 계산해도 100개 이상의 데이터를 Array에 담아야 합니다.

그리고 **1초 정도이지만 사용자가 알 수 있을 만큼 느렸습니다.**

서비스 기간이 길어질수록 년도 데이터는 늘어나기만 할 것이기 때문에

직접 구현하는 것이 빠른 상황이 되었죠.



## 구현 방향

렌더링에 필요한 데이터 수를 줄였습니다.



### 고려 점

가이드에 나와있지 않지만, 기본적인 Date Picker라면 필요할 요소를 추려냅니다. 

- 매월 말일이 월마다 다르다. 
  - ex. 3월 31일이 선택된 상태에서, 월을 2로 바꾸면 일은 28 혹은 29일이 되어야 함
- 휠의 시작, 끝에 도달했을 때는 어떤 값을 보여주어야 할까?
  - UI 담당자분과 논의 필요 -> 휠은 반복되지 않는 것으로 결정



### 컴포넌트 구성

- Wheel.tsx

  - 년 / 월 / 일 각 휠로 사용할 컴포넌트입니다.
  - 휠의 중앙 값과 스크롤 위치의 차이를 계산합니다. 
  - 값이 바뀌는 임계점에 도달하면, 부모 컴포넌트로 바뀐 데이터를 보냅니다. 
- DatePicker.tsx

  - 년, 월, 일 정보를 합쳐 날짜를 관리할 컴포넌트입니다. 
  - 일자가 말일로 정해진 상태에서 년/월이 바뀔 경우 월말의 날짜를 관리합니다. 
  - 날짜가 바뀌면, 부모 컴포넌트로 바뀐 날짜를 보냅니다.

- BirthdayBottomSheet.tsx
  - 바텀시트의 상태(초기 값, 열림 상태, 날짜)를 관리할 컴포넌트 입니다. 
  - 바텀 시트를 호출한 컴포넌트에서 날짜를 받아 스토어에 저장하도록 값을 보냅니다.




### 주요 로직

1. 휠의 데이터가 아무리 많아도 실제 렌더링 때 필요한 데이터는 각 휠 당 최대 土2개 입니다. 

2. 선택된 값을 관리할 수 있기 때문에, 값이 변할 때마다 **선택된 값을 중심으로 土3개의 값만 배열**로 만듦니다.

   * 화면에 나오는 데이터는 5개이지만, 스크롤이 가능하려면 위, 아래 각각 하나씩의 데이터가 더 필요합니다. 

   ```typescript
   // Wheel.tsx
   	// 스크롤을 고려해 7개의 빈 어레이 생성 후 현재 일자를 중심으로 값 삽입
       const wheelData = Array.from({ length: 7 }, (_, idx) => {
         // 배열의 중앙 값이 init, 현재 값
         let currentDate = init + idx - 3;
   
         // 최소, 최대일을 벗어나는 경우 undefined로 설정
         if (currentDate > max || currentDate < min) {
           currentDate = undefined;
         }
   
         return currentDate;
       });
   ```

3. 스크롤의 최상단 값과 기존 스크롤 위치의 차이를 통해 사용자가 값을 변경했는지 확인하고 업데이트 합니다. 

   ```typescript
   // Wheel.tsx
      // 중앙 값을 기준으로 하기 위해 초기값을 30px로 변경
      const [scrollPoint, setScrollPoint] = useState(30);
   
      const handleScroll = (e: any) => {
         e.preventDefault();
   
         const top = wheelRef.current.scrollTop;
   
         // 천천히 스크롤을 할 때, 여러 값을 보내지 않도록 조건 설정
         // 이 조건이 없을 경우 scrollTop이 0인 상태에서 여러번 콜백을 하여 날짜가 한꺼번에 변경됨
         if (scrollPoint !== top) {
           if (top === 0) { // TODO: 일부 기기 미작동
             // 스크롤을 올릴 경우 전일자를 콜백
             wheelData[2] && props.callbackF(wheelData[2]);
             wheelRef.current.scrollTop = 30;
           } else if (top === 60) { // TODO: 일부 기기 미작동
             // 스크롤을 내릴 경우 명일자를 콜백
             wheelData[4] && props.callbackF(wheelData[4]);
             wheelRef.current.scrollTop = 30;
           }
           setScrollPoint(top);
         }
   
         if (top > 59 || top < 1) {
           // 스크롤을 천천히 하는 상태에서 휠의 범위를 벗어날 경우 휠을 중앙으로 초기화
           wheelRef.current.scrollTop = 30;
         }
       };
   ```



## 시행착오

### 디바이스 환경의 차이

#### 문제

일부 기기에서는 스크롤이 움직이지 않는 문제가 있다는 QA 팀의 테스트 결과를 받았습니다. 

개발자에게 이슈 자체는 실력을 발전시킬 기회이지만,

문제의 원인을 파악할 수 없는 상황만큼 힘든 순간도 없죠. 

특히, 항상 안되는 때보다 어떤 기기에서는 되고, 다른 기기에서는 안되는지 알 수 없을 때가 난감합니다.

심지어 안되는 기기도, 되는 순간들이 있을 때 원인을 파악하기 어렵게 됩니다. 

그 유명한, **"이건 왜 되는거지?"** 의 순간이 찾아왔어요. 

아무리 코드를 읽어도 로직의 문제를 찾을 수 없었어요.



결국 이슈 해결을 위해 QA팀에서 문제가 되는 기기를 빌려왔습니다. 

와플수학의 안드로이드 앱은 연구소 환경 / QA 환경 / 빌드 환경으로 나누어서 버전 관리를 합니다. 

다행이도 빌드 환경을 제외하고는 모바일 기기도 웹 콘솔을 확인할 수 있는 디버깅 설정을 해둔 상태였습니다. 



#### 해결

기기를 연결하고는 안드로이드 버전의 문제라는 점을 바로 알 수 있었습니다. 

`wheelRef.current.scrollTop` 이 정수가 아니라, 소숫점 이하의 값도 나올 수 있다는 점을 처음 발견한 것이죠!

스크롤을 빨리 할 경우 `wheelRef.current.scrollTop` 의 값이 정확히 0이 되지 않으면 값을 업데이트 하지 않는 것입니다.



**0px이 아니라, 0.1px의 값이 나올 수 있는 상황**인 것은 테스트를 통해서 알 수 있었습니다. 

브라우저, 디바이스 환경에 따라 코드가 다르게 동작할 수 있다는 점은 프론트 개발자의 숙명이지만

개발의 재미를 높여주기도 합니다. 



생각보다 간단하게 문제를 풀고 마무리 했습니다. 

```typescript
// Wheel.tsx
  //...
      if (scrollPoint !== top) {
        if (top < 1) { // 실수 값을 관리할 수 있도록 동치에서 비교로 코드 변경
        //...
        } else if (top > 59) {
		//...
        }
        setScrollPoint(top);
      }
	// ...
    };
```



## 마치며

프론트에서 더 나은 렌더링을 위해 데이터를 어떻게 구성할지 고민하는 시간이었습니다. 

답을 알고 난 뒤, 글을 쓸 때는 참 간단한 일이지만

실제 구현을 할 때에는 쉽지 않은 일이었습니다. 



이슈를 처리할 때는 코드만으로 발견하지 못하는 답이

모바일 환경에 따라 달라지는 순간을 찾으면서 테스트 환경의 중요성을 깨닫기도 했죠.

브라우저에 따라 코드가 다르게 동작하는 순간은 겪어봤어도 모바일은 처음이었습니다. 



늘 예상 가능하다면, 재미가 없을 것입니다. 

사소해 보이는 1초, 더 사소해보이는 0.1의 차이를 좁혀가면서

사용자가 편리함을 느끼는 서비스를 만들어나가는 시간이 되었습니다. 



